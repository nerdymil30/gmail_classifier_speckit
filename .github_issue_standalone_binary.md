# feat: Add standalone binary distribution for non-technical users

## Overview

Enable distribution of the Gmail classifier as a standalone binary executable for regular users who want a simple email organization tool without Python development environment setup. Target use case: users receiving **max 20 emails per hour** who need automated classification without technical expertise.

## Problem Statement

### Current State
The Gmail classifier currently requires:
- Python 3.11+ installation and virtual environment setup
- Manual dependency installation via `pip` or `uv`
- Google Cloud Console navigation to create OAuth credentials
- Manual `credentials.json` download and placement
- `.env` file configuration
- Terminal/CLI proficiency
- Understanding of OAuth scopes and API setup

**Current entry points:**
- `src/gmail_classifier/cli/main.py:19` - Click-based CLI entry point
- `pyproject.toml:54-55` - Console script definition

### Pain Points for Non-Technical Users
1. **Setup complexity**: 8+ manual steps before first use
2. **Python knowledge barrier**: Virtual environments, package managers
3. **Google Cloud Console**: Complex credential creation process
4. **CLI-only**: No graphical interface or visual feedback
5. **Platform-specific issues**: Keyring configuration varies by OS

### Target Audience Shift
- **Current users**: Developers comfortable with Python/CLI
- **New target**: Regular users who receive ~20 emails/hour and want automated organization
- **Key requirement**: Zero Python knowledge required

## Proposed Solution

Create **standalone binary executables** for Windows (.exe), macOS (.app), and Linux (AppImage/binary) while maintaining existing source installation option for developers.

### High-Level Approach

**1. Packaging Tool: PyInstaller**
- Proven ML library support (PyTorch, transformers)
- Works with Google API clients (with proper metadata copying)
- Fast build times (2-5 minutes)
- Active community and hook ecosystem

**2. Distribution Strategy: One-Dir + Installer**
- Avoid one-file mode (antivirus false positives)
- Use platform-specific installers:
  - Windows: Inno Setup
  - macOS: py2app with code signing
  - Linux: AppImage or .deb/.rpm

**3. OAuth Handling for Distributed Apps**
- Use Authorization Code + PKCE flow (public client pattern)
- System browser redirect to `http://localhost:random_port`
- Per Google's guidance: "client secret is not treated as a secret for desktop apps"
- Store refresh tokens in system keyring (already implemented)

**4. Simplified First-Run Experience**
- Interactive setup wizard (CLI or simple GUI)
- Clear instructions for obtaining OAuth credentials
- Automatic model download (all-MiniLM-L6-v2, ~80MB)
- Configuration persistence in platform-appropriate directories

## Technical Approach

### Architecture Impacts

**Existing Code Compatibility:**
- ‚úÖ Current implementation at `src/gmail_classifier/auth/gmail_auth.py:113-117` already uses correct OAuth flow
- ‚úÖ Secure file permissions enforced at `auth/gmail_auth.py:144`
- ‚úÖ Keyring integration at `auth/gmail_auth.py:187-206`
- ‚úÖ SQLite database location logic at `src/gmail_classifier/lib/session_db.py:53`

**Required Changes:**
1. **PyInstaller Configuration** (new file: `gmail-classifier.spec`)
2. **Platform-appropriate data directories** (enhance `src/gmail_classifier/lib/config/storage_config.py:42-52`)
3. **Build scripts** (new: `scripts/build_binary.py`)
4. **Optional GUI wrapper** (new: `src/gmail_classifier/gui/` - optional phase 2)

### Implementation Phases

#### Phase 1: Core Binary Packaging ‚öôÔ∏è

**Tasks:**
- Create PyInstaller spec file with metadata copying for google-api-python-client
- Configure hidden imports for anthropic, keyring, google-auth-oauthlib
- Implement cross-platform data directory resolution
- Update storage_config.py to detect frozen executable environment
- Build and test basic binary on primary development platform

**Success Criteria:**
- Binary launches and runs `gmail-classifier --help`
- OAuth flow completes successfully
- Database creates in user data directory (not temp dir)
- Keyring stores/retrieves credentials

**File Changes:**
- **new: gmail-classifier.spec**: PyInstaller configuration with metadata copying
- **modified: src/gmail_classifier/lib/config/storage_config.py**: Add `get_user_data_dir()` with platform detection
- **modified: src/gmail_classifier/cli/main.py**: Detect frozen mode with `getattr(sys, 'frozen', False)`
- **new: scripts/build_binary.py**: Build automation script

**Estimated Effort:** 3-5 days

#### Phase 2: Cross-Platform Support üåç

**Tasks:**
- Set up build environments (Windows VM, macOS, Linux)
- Create platform-specific installers (Inno Setup, py2app, AppImage)
- Test keyring on all platforms (WinVaultKeyring, macOS Keychain, SecretService)
- Implement keyring fallback strategy for unsupported platforms
- Handle platform-specific OAuth quirks

**Success Criteria:**
- Three distributable packages: .exe installer, .dmg, .AppImage
- All platforms pass OAuth + classification test
- Keyring works or gracefully falls back
- Executables < 150MB (without model)

**File Changes:**
- **new: installers/windows/gmail_classifier.iss**: Inno Setup script
- **new: installers/macos/setup.py**: py2app configuration
- **new: installers/linux/build_appimage.sh**: AppImage build script
- **new: src/gmail_classifier/lib/keyring_manager.py**: Platform-specific keyring with fallback

**Estimated Effort:** 5-7 days

#### Phase 3: User Experience Polish ‚ú®

**Tasks:**
- Create first-run setup wizard (enhanced CLI prompts or simple GUI)
- Add progress indicators for model download
- Implement friendly error messages for non-technical users
- Add auto-update mechanism (using tufup library)
- Create user documentation (non-developer focused)

**Success Criteria:**
- First-run experience requires no terminal knowledge
- Error messages explain problems in plain English
- Auto-update works without user intervention
- Documentation tested with non-technical users

**File Changes:**
- **new: src/gmail_classifier/cli/setup_wizard.py**: Interactive setup flow
- **new: src/gmail_classifier/lib/auto_update.py**: tufup integration
- **new: docs/user_guide.md**: End-user documentation
- **modified: src/gmail_classifier/cli/main.py**: Enhanced error formatting

**Estimated Effort:** 4-6 days

#### Phase 4: Testing & Distribution üöÄ

**Tasks:**
- Code signing certificates for Windows/macOS (reduces antivirus issues)
- Security audit of bundled dependencies
- Performance testing with 20 emails/hour use case
- Create GitHub release workflow
- Set up distribution channels (GitHub Releases, website)

**Success Criteria:**
- Binaries pass Windows Defender and macOS Gatekeeper
- Performance: < 10s per classification check (20 emails)
- Automated release pipeline via GitHub Actions
- Download page with clear installation instructions

**File Changes:**
- **new: .github/workflows/build_binaries.yml**: CI/CD for binary builds
- **new: scripts/sign_binary.py**: Code signing automation
- **new: tests/performance/test_binary_performance.py**: Binary-specific perf tests

**Estimated Effort:** 3-4 days

### Detailed Technical Specifications

#### PyInstaller Metadata Copying

**Critical for google-api-python-client** (from research):
```python
# gmail-classifier.spec
from PyInstaller.utils.hooks import copy_metadata

datas = []
datas += copy_metadata('google-api-core')
datas += copy_metadata('google-api-python-client')
datas += copy_metadata('google-auth-httplib2')
datas += copy_metadata('google-auth-oauthlib')
datas += copy_metadata('anthropic')
datas += copy_metadata('httpx')
datas += copy_metadata('pydantic')
datas += copy_metadata('keyring')
```

#### Platform-Specific Data Directories

**storage_config.py enhancement:**
```python
# src/gmail_classifier/lib/config/storage_config.py

def get_user_data_dir() -> Path:
    """Get platform-appropriate data directory for standalone apps."""
    import sys

    if getattr(sys, 'frozen', False):
        # Running as binary
        if sys.platform == 'win32':
            base = Path(os.environ['APPDATA'])
        elif sys.platform == 'darwin':
            base = Path.home() / 'Library' / 'Application Support'
        else:  # Linux
            base = Path(os.environ.get('XDG_DATA_HOME',
                        Path.home() / '.local' / 'share'))

        app_dir = base / 'gmail-classifier'
    else:
        # Running from source - maintain current behavior
        app_dir = Path.home() / '.gmail_classifier'

    app_dir.mkdir(parents=True, exist_ok=True, mode=0o700)
    return app_dir
```

#### Keyring Fallback Strategy

**For platforms without system keyring:**
```python
# src/gmail_classifier/lib/keyring_manager.py

import keyring
from keyrings.alt.file import EncryptedKeyring

def initialize_keyring():
    """Initialize keyring with fallback for unsupported platforms."""
    try:
        # Test if system keyring works
        keyring.get_keyring()
    except Exception:
        # Fall back to encrypted file
        keyring.set_keyring(EncryptedKeyring())
        logger.warning("System keyring unavailable, using encrypted file")
```

## Acceptance Criteria

### Functional Requirements

- [ ] **Binary Creation**: PyInstaller successfully bundles application with all dependencies
- [ ] **OAuth Flow**: Gmail authentication completes in standalone binary using system browser
- [ ] **Credential Storage**: Keyring stores and retrieves tokens on all platforms
- [ ] **Database Persistence**: SQLite database creates in user data directory (survives app restart)
- [ ] **Classification**: Full classify ‚Üí review ‚Üí apply workflow functions identically to source install
- [ ] **Cross-Platform**: Binaries work on Windows 10+, macOS 11+, Linux (Ubuntu 20.04+)
- [ ] **Model Handling**: Sentence transformers model downloads on first run (if using Claude API, verify anthropic SDK works)

### Non-Functional Requirements

- [ ] **Size**: Binary < 150MB (excluding downloaded model)
- [ ] **Performance**: Classification check completes in < 10s for 20 emails
- [ ] **Startup Time**: Application launches in < 5s
- [ ] **Security**: Antivirus false positive rate < 5% (test with VirusTotal)
- [ ] **Memory**: Peak memory usage < 1GB for 20 emails/hour use case

### Quality Gates

- [ ] **Test Coverage**: Binary-specific tests for frozen environment detection
- [ ] **Documentation**: User guide for non-technical audience (install, setup, use)
- [ ] **Code Review**: Security review of credential handling in binary
- [ ] **User Testing**: 3+ non-technical users complete setup without assistance

## Alternative Approaches Considered

### 1. Nuitka Instead of PyInstaller
**Pros:** Faster runtime, better performance
**Cons:** 60+ minute build times, complex setup, less ML library support
**Decision:** Rejected - Build time too slow for iteration

### 2. Web Application (Electron/Tauri)
**Pros:** Cross-platform, modern UI, easier updates
**Cons:** Larger size, OAuth redirect URI complexity, server hosting costs
**Decision:** Deferred - Consider for Phase 5 if binary adoption is strong

### 3. Docker Container
**Pros:** Reproducible environment, easy dependency management
**Cons:** Requires Docker knowledge, not truly "standalone"
**Decision:** Rejected - Doesn't solve non-technical user barrier

### 4. Browser Extension
**Pros:** No installation, automatic updates
**Cons:** Limited Gmail API access, Chrome Web Store approval process
**Decision:** Rejected - API limitations too restrictive

## Success Metrics

**Primary:**
- **Adoption Rate**: 25% of new users choose binary over source install within 3 months
- **Setup Completion**: 90% of binary users complete first classification within 15 minutes
- **Support Tickets**: < 5 binary-specific issues per 100 downloads

**Secondary:**
- **Platform Distribution**: 45% Windows, 35% macOS, 20% Linux downloads
- **Retention**: 70% of binary users classify emails weekly after 1 month
- **Performance**: Average classification time < 5s for 20-email batch

## Dependencies & Prerequisites

**Development Environment:**
- PyInstaller 6.0+
- pyinstaller-hooks-contrib (latest)
- Access to Windows, macOS, Linux for builds (VMs acceptable)
- Code signing certificates (optional but recommended, $100-300/year)

**External Services:**
- GitHub Releases for binary hosting
- Optional: CDN for model downloads (reduce first-run time)

**Documentation:**
- User guide for OAuth credential setup
- Troubleshooting guide for common issues
- Build instructions for contributors

**Blockers:**
- None - all dependencies available, OAuth flow proven

## Risk Analysis & Mitigation

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Antivirus false positives | High | Medium | Code signing, one-dir mode, VirusTotal monitoring |
| Keyring failure on Linux | Medium | Medium | Fallback to encrypted file backend |
| PyInstaller metadata issues | High | Low | Comprehensive .spec file, extensive testing |
| Large binary size | Low | High | Exclude unnecessary packages, use UPX compression |
| OAuth redirect blocked | Medium | Low | Use random port, clear firewall instructions |
| Model download failures | Medium | Medium | Retry logic, mirror URLs, bundle option |

## Resource Requirements

**Developer Time:** 15-22 days total across 4 phases
**Infrastructure:**
- 3 build machines/VMs (Windows, macOS, Linux)
- ~500MB GitHub Release storage per version (3 platforms)
- Optional: Code signing certificates ($100-300/year)

**Tools/Services:**
- PyInstaller (free, MIT license)
- Inno Setup (free, Windows installer)
- py2app (free, macOS)
- AppImage tools (free, Linux)
- tufup for auto-updates (free, MIT license)

## Future Considerations

### Phase 5: GUI Application (Deferred)
- Full graphical interface with system tray icon
- Visual label assignment and configuration
- Built with Tkinter (included) or PyQt (add dependency)
- Estimated: +10-15 days development

### Phase 6: Background Service
- Automatic classification every hour
- System startup integration
- Notification center integration for new labels
- Estimated: +5-7 days development

### Phase 7: Model Optimization
- Switch to smaller model for faster classification
- Optional GPU acceleration for power users
- On-device fine-tuning for personalization
- Estimated: +8-12 days development

## Documentation Plan

**User Documentation:**
- [ ] **Installation Guide** (installers/README.md): Platform-specific install instructions
- [ ] **Setup Wizard** (docs/setup.md): Step-by-step first-run guide with screenshots
- [ ] **Troubleshooting** (docs/troubleshooting.md): Common issues and solutions
- [ ] **FAQ** (docs/faq.md): OAuth questions, model downloads, keyring setup

**Developer Documentation:**
- [ ] **Build Instructions** (BUILDING.md): How to build binaries locally
- [ ] **Release Process** (docs/releasing.md): Automated and manual release steps
- [ ] **Architecture** (docs/binary_architecture.md): How frozen mode differs from source

**Updates Required:**
- [ ] **README.md**: Add binary download links and installation section
- [ ] **CLAUDE.md**: Add binary build commands to project guidelines

## References & Research

### Internal References

**Architecture & Configuration:**
- OAuth implementation: `src/gmail_classifier/auth/gmail_auth.py:113-117` (local server flow)
- Credential storage: `src/gmail_classifier/auth/gmail_auth.py:187-206` (keyring)
- File permissions: `src/gmail_classifier/auth/gmail_auth.py:144` (secure 0o600)
- Database setup: `src/gmail_classifier/lib/session_db.py:53` (SQLite WAL mode)
- Storage config: `src/gmail_classifier/lib/config/storage_config.py:42-52` (data directories)

**Entry Points:**
- CLI main: `src/gmail_classifier/cli/main.py:19`
- Console script: `pyproject.toml:54-55`

**Dependencies:**
- Project config: `pyproject.toml:19-37`

### External References

**PyInstaller & Packaging:**
- [PyInstaller Official Docs](https://pyinstaller.org/en/stable/)
- [google-api-python-client packaging issue](https://github.com/googleapis/google-api-python-client/issues/876)
- [keyring backend discovery](https://github.com/jaraco/keyring/issues/399)
- [PyInstaller hooks contrib](https://github.com/pyinstaller/pyinstaller-hooks-contrib)

**OAuth Best Practices:**
- [RFC 8252: OAuth 2.0 for Native Apps](https://datatracker.ietf.org/doc/html/rfc8252)
- [Google OAuth for Desktop Apps](https://developers.google.com/identity/protocols/oauth2/native-app)
- [PKCE Flow Specification](https://datatracker.ietf.org/doc/html/rfc7636)

**Distribution & Security:**
- [tufup: Secure Python updates](https://github.com/dennisvang/tufup)
- [Inno Setup](https://jrsoftware.org/isinfo.php)
- [py2app](https://py2app.readthedocs.io/)
- [AppImage](https://appimage.org/)

**Model & Dependencies:**
- [sentence-transformers packaging](https://github.com/UKPLab/sentence-transformers/issues/1409)
- [Anthropic Python SDK](https://github.com/anthropics/anthropic-sdk-python)
- [keyring library](https://github.com/jaraco/keyring)

### Related Work

**Research Documents:**
- Comprehensive research report: `research_standalone_binary_best_practices.md` (900+ lines, created during planning)

**GitHub Discussions:**
- No related issues found in current repository
- Previous PRs: #1, #2, #3 (feature implementation, not distribution)

---

## Example MVP Code Snippets

### gmail-classifier.spec
```python
# -*- mode: python ; coding: utf-8 -*-
from PyInstaller.utils.hooks import copy_metadata

block_cipher = None

# Metadata copying for runtime discovery
datas = []
datas += copy_metadata('google-api-core')
datas += copy_metadata('google-api-python-client')
datas += copy_metadata('google-auth-httplib2')
datas += copy_metadata('google-auth-oauthlib')
datas += copy_metadata('anthropic')
datas += copy_metadata('keyring')

hiddenimports = [
    'googleapiclient',
    'googleapiclient.discovery',
    'google.auth',
    'google.oauth2',
    'anthropic',
    'keyring.backends',
    'click',
]

a = Analysis(
    ['src/gmail_classifier/cli/main.py'],
    pathex=[],
    binaries=[],
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=['tkinter', 'matplotlib', 'PIL'],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='gmail-classifier',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=True,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='gmail-classifier',
)
```

### scripts/build_binary.py
```python
#!/usr/bin/env python3
"""Build standalone binary for Gmail Classifier."""

import subprocess
import sys
import platform
from pathlib import Path

def build_binary():
    """Build using PyInstaller."""
    spec_file = Path(__file__).parent.parent / 'gmail-classifier.spec'

    cmd = ['pyinstaller', '--clean', str(spec_file)]

    print(f"Building for {platform.system()}...")
    result = subprocess.run(cmd, check=False)

    if result.returncode == 0:
        print(f"‚úì Build successful! Binary in: dist/gmail-classifier/")
    else:
        print(f"‚úó Build failed with code {result.returncode}")
        sys.exit(1)

if __name__ == '__main__':
    build_binary()
```

### src/gmail_classifier/lib/config/storage_config.py (enhancement)
```python
import sys
from pathlib import Path

def get_user_data_dir() -> Path:
    """Get platform-appropriate data directory."""
    if getattr(sys, 'frozen', False):
        # Running as binary - use OS-specific app data
        if sys.platform == 'win32':
            base = Path(os.environ['APPDATA'])
        elif sys.platform == 'darwin':
            base = Path.home() / 'Library' / 'Application Support'
        else:
            base = Path(os.environ.get('XDG_DATA_HOME',
                        Path.home() / '.local' / 'share'))
        app_dir = base / 'gmail-classifier'
    else:
        # Running from source - maintain current behavior
        app_dir = Path.home() / '.gmail_classifier'

    app_dir.mkdir(parents=True, exist_ok=True, mode=0o700)
    return app_dir

# Update existing code to use this function
session_db_path = get_user_data_dir() / 'sessions.db'
logs_dir = get_user_data_dir() / 'logs'
config_path = get_user_data_dir() / 'config.yml'
```
